package com.thaiinsurance.autoinsurance.service;

import com.thaiinsurance.autoinsurance.dto.ClaimSubmissionRequest;
import com.thaiinsurance.autoinsurance.model.Claim;
import com.thaiinsurance.autoinsurance.model.ClaimDocument;
import com.thaiinsurance.autoinsurance.model.Policy;
import com.thaiinsurance.autoinsurance.repository.ClaimRepository;
import com.thaiinsurance.autoinsurance.repository.PolicyRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Service for Claims management with Thai insurance specifics
 */
@Service
@Transactional
public class ClaimsService {
    
    private static final Logger logger = LoggerFactory.getLogger(ClaimsService.class);
    
    private static final String UPLOAD_DIR = "uploads/claims";
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    private static final String[] ALLOWED_IMAGE_TYPES = {"jpg", "jpeg", "png", "gif"};
    private static final String[] ALLOWED_VIDEO_TYPES = {"mp4", "mov", "avi"};
    private static final String[] ALLOWED_DOCUMENT_TYPES = {"pdf", "doc", "docx"};
    
    @Autowired
    private ClaimRepository claimRepository;
    
    @Autowired
    private PolicyRepository policyRepository;
    
    /**
     * Submit new claim
     */
    public Claim submitClaim(ClaimSubmissionRequest request) {
        logger.info("Submitting claim for policy {}", request.getPolicyId());
        
        // Validate policy exists and is active
        Policy policy = policyRepository.findById(request.getPolicyId())
            .orElseThrow(() -> new IllegalArgumentException("Policy not found"));
            
        if (policy.getStatus() != Policy.PolicyStatus.ACTIVE) {
            throw new IllegalArgumentException("Policy is not active");
        }
        
        // Validate incident date is within policy period
        if (request.getIncidentDateTime().toLocalDate().isBefore(policy.getStartDate()) ||
            request.getIncidentDateTime().toLocalDate().isAfter(policy.getEndDate())) {
            throw new IllegalArgumentException("Incident date is outside policy coverage period");
        }
        
        // Create claim
        Claim claim = new Claim();
        claim.setClaimNumber(generateClaimNumber());
        claim.setPolicy(policy);
        claim.setIncidentType(request.getIncidentType());
        claim.setIncidentDate(request.getIncidentDateTime().toLocalDate());
        claim.setIncidentTime(request.getIncidentDateTime().toLocalTime());
        claim.setIncidentLocation(request.getIncidentLocation());
        claim.setIncidentDescription(request.getIncidentDescription());
        claim.setPoliceReportNumber(request.getPoliceReportNumber());
        claim.setThirdPartyInvolved(request.getThirdPartyInvolved());
        claim.setThirdPartyContactInfo(request.getThirdPartyContactInfo());
        claim.setWitnessName(request.getWitnessName());
        claim.setWitnessContactInfo(request.getWitnessContactInfo());
        claim.setIsDriverInjured(request.isDriverInjured());
        claim.setArePassengersInjured(request.arePassengersInjured());
        claim.setIsThirdPartyInjured(request.isThirdPartyInjured());
        claim.setInjuryDetails(request.getInjuryDetails());
        claim.setEmergencyContactName(request.getEmergencyContactName());
        claim.setEmergencyContactPhone(request.getEmergencyContactPhone());
        claim.setAdditionalRemarks(request.getAdditionalRemarks());
        claim.setStatus(Claim.ClaimStatus.SUBMITTED);
        claim.setPriority(determinePriority(request));
        
        // Save claim first to get ID
        claim = claimRepository.save(claim);
        
        // Handle file uploads
        try {
            handleFileUploads(claim, request);
        } catch (Exception e) {
            logger.error("Failed to upload files for claim {}", claim.getClaimNumber(), e);
            // Continue - files can be uploaded later
        }
        
        logger.info("Created claim {} for policy {}", claim.getClaimNumber(), policy.getPolicyNumber());
        return claim;
    }
    
    /**
     * Get all claims with pagination
     */
    @Transactional(readOnly = true)
    public Page<Claim> getAllClaims(Pageable pageable) {
        return claimRepository.findAll(pageable);
    }
    
    /**
     * Search claims
     */
    @Transactional(readOnly = true)
    public Page<Claim> searchClaims(String searchTerm, Pageable pageable) {
        return claimRepository.searchClaims(searchTerm, pageable);
    }
    
    /**
     * Get claim by ID
     */
    @Transactional(readOnly = true)
    public Optional<Claim> getClaimById(Long id) {
        return claimRepository.findById(id);
    }
    
    /**
     * Get claims by customer
     */
    @Transactional(readOnly = true)
    public List<Claim> getClaimsByCustomer(Long customerId) {
        return claimRepository.findByPolicyCustomerId(customerId);
    }
    
    /**
     * Get claims by policy
     */
    @Transactional(readOnly = true)
    public List<Claim> getClaimsByPolicy(Long policyId) {
        return claimRepository.findByPolicyId(policyId);
    }
    
    /**
     * Update claim status
     */
    public Claim updateClaimStatus(Long claimId, Claim.ClaimStatus status, String remarks) {
        Claim claim = claimRepository.findById(claimId)
            .orElseThrow(() -> new IllegalArgumentException("Claim not found"));
        
        Claim.ClaimStatus oldStatus = claim.getStatus();
        claim.setStatus(status);
        
        // Set status-specific dates
        switch (status) {
            case UNDER_REVIEW:
                claim.setReviewStartDate(LocalDate.now());
                break;
            case APPROVED:
                claim.setApprovedDate(LocalDate.now());
                break;
            case REJECTED:
                claim.setRejectedDate(LocalDate.now());
                claim.setRejectionReason(remarks);
                break;
            case SETTLED:
                claim.setSettlementDate(LocalDate.now());
                break;
        }
        
        if (remarks != null && !remarks.trim().isEmpty()) {
            String currentRemarks = claim.getAdditionalRemarks() != null ? 
                claim.getAdditionalRemarks() : "";
            String newRemarks = String.format("[%s] Status changed from %s to %s: %s\n%s",
                LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),
                oldStatus, status, remarks, currentRemarks);
            claim.setAdditionalRemarks(newRemarks);
        }
        
        return claimRepository.save(claim);
    }
    
    /**
     * Assign surveyor to claim
     */
    public Claim assignSurveyor(Long claimId, String surveyorName, String surveyorPhone) {
        Claim claim = claimRepository.findById(claimId)
            .orElseThrow(() -> new IllegalArgumentException("Claim not found"));
        
        claim.setSurveyorName(surveyorName);
        claim.setSurveyorPhone(surveyorPhone);
        claim.setSurveyorAssignedDate(LocalDate.now());
        
        if (claim.getStatus() == Claim.ClaimStatus.SUBMITTED) {
            claim.setStatus(Claim.ClaimStatus.UNDER_REVIEW);
            claim.setReviewStartDate(LocalDate.now());
        }
        
        return claimRepository.save(claim);
    }
    
    /**
     * Set repair estimate
     */
    public Claim setRepairEstimate(Long claimId, BigDecimal estimatedAmount, String repairDetails) {
        Claim claim = claimRepository.findById(claimId)
            .orElseThrow(() -> new IllegalArgumentException("Claim not found"));
        
        claim.setEstimatedAmount(estimatedAmount);
        claim.setRepairDetails(repairDetails);
        claim.setEstimateDate(LocalDate.now());
        
        return claimRepository.save(claim);
    }
    
    /**
     * Approve settlement
     */
    public Claim approveSettlement(Long claimId, BigDecimal settlementAmount, String paymentMethod) {
        Claim claim = claimRepository.findById(claimId)
            .orElseThrow(() -> new IllegalArgumentException("Claim not found"));
        
        if (claim.getStatus() != Claim.ClaimStatus.APPROVED) {
            throw new IllegalArgumentException("Claim must be approved before settlement");
        }
        
        claim.setSettlementAmount(settlementAmount);
        claim.setSettlementDate(LocalDate.now());
        claim.setStatus(Claim.ClaimStatus.SETTLED);
        
        return claimRepository.save(claim);
    }
    
    /**
     * Get claims statistics
     */
    @Transactional(readOnly = true)
    public ClaimStatistics getStatistics() {
        ClaimStatistics stats = new ClaimStatistics();
        stats.setTotalClaims(claimRepository.count());
        stats.setSubmittedClaims(claimRepository.countByStatus(Claim.ClaimStatus.SUBMITTED));
        stats.setUnderReviewClaims(claimRepository.countByStatus(Claim.ClaimStatus.UNDER_REVIEW));
        stats.setApprovedClaims(claimRepository.countByStatus(Claim.ClaimStatus.APPROVED));
        stats.setRejectedClaims(claimRepository.countByStatus(Claim.ClaimStatus.REJECTED));
        stats.setSettledClaims(claimRepository.countByStatus(Claim.ClaimStatus.SETTLED));
        
        return stats;
    }
    
    // Private helper methods
    
    private String generateClaimNumber() {
        String timestamp = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        String uuid = UUID.randomUUID().toString().substring(0, 8).toUpperCase();
        return "CLM-" + timestamp + "-" + uuid;
    }
    
    private Claim.PriorityLevel determinePriority(ClaimSubmissionRequest request) {
        // High priority for injuries or major incidents
        if (request.isDriverInjured() || request.arePassengersInjured() || 
            request.isThirdPartyInjured()) {
            return Claim.PriorityLevel.HIGH;
        }
        
        // High priority for certain incident types
        if (request.getIncidentType() == Claim.IncidentType.FIRE ||
            request.getIncidentType() == Claim.IncidentType.THEFT ||
            request.getIncidentType() == Claim.IncidentType.NATURAL_DISASTER) {
            return Claim.PriorityLevel.HIGH;
        }
        
        // Medium priority for accidents with third parties
        if (request.getThirdPartyInvolved() != null && !request.getThirdPartyInvolved().trim().isEmpty()) {
            return Claim.PriorityLevel.MEDIUM;
        }
        
        return Claim.PriorityLevel.LOW;
    }
    
    private void handleFileUploads(Claim claim, ClaimSubmissionRequest request) throws Exception {
        String claimDir = UPLOAD_DIR + "/" + claim.getClaimNumber();
        Path claimPath = Paths.get(claimDir);
        Files.createDirectories(claimPath);
        
        // Handle photos
        if (request.getPhotos() != null && !request.getPhotos().isEmpty()) {
            for (int i = 0; i < request.getPhotos().size(); i++) {
                MultipartFile photo = request.getPhotos().get(i);
                saveFile(photo, claimPath.resolve("photo_" + i + "_" + photo.getOriginalFilename()), 
                        claim, ClaimDocument.DocumentType.PHOTO);
            }
        }
        
        // Handle videos
        if (request.getVideos() != null && !request.getVideos().isEmpty()) {
            for (int i = 0; i < request.getVideos().size(); i++) {
                MultipartFile video = request.getVideos().get(i);
                saveFile(video, claimPath.resolve("video_" + i + "_" + video.getOriginalFilename()), 
                        claim, ClaimDocument.DocumentType.VIDEO);
            }
        }
        
        // Handle police report
        if (request.getPoliceReport() != null) {
            saveFile(request.getPoliceReport(), 
                    claimPath.resolve("police_report_" + request.getPoliceReport().getOriginalFilename()), 
                    claim, ClaimDocument.DocumentType.POLICE_REPORT);
        }
        
        // Handle medical report
        if (request.getMedicalReport() != null) {
            saveFile(request.getMedicalReport(), 
                    claimPath.resolve("medical_report_" + request.getMedicalReport().getOriginalFilename()), 
                    claim, ClaimDocument.DocumentType.MEDICAL_REPORT);
        }
    }
    
    private void saveFile(MultipartFile file, Path destination, Claim claim, 
                         ClaimDocument.DocumentType documentType) throws Exception {
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("File size exceeds maximum allowed size");
        }
        
        Files.copy(file.getInputStream(), destination);
        
        // Create document record
        ClaimDocument document = new ClaimDocument();
        document.setClaim(claim);
        document.setDocumentType(documentType);
        document.setFileName(file.getOriginalFilename());
        document.setFilePath(destination.toString());
        document.setFileSize(file.getSize());
        document.setContentType(file.getContentType());
        
        claim.getDocuments().add(document);
    }
    
    // Inner class for statistics
    public static class ClaimStatistics {
        private long totalClaims;
        private long submittedClaims;
        private long underReviewClaims;
        private long approvedClaims;
        private long rejectedClaims;
        private long settledClaims;
        
        // Getters and setters
        public long getTotalClaims() { return totalClaims; }
        public void setTotalClaims(long totalClaims) { this.totalClaims = totalClaims; }
        public long getSubmittedClaims() { return submittedClaims; }
        public void setSubmittedClaims(long submittedClaims) { this.submittedClaims = submittedClaims; }
        public long getUnderReviewClaims() { return underReviewClaims; }
        public void setUnderReviewClaims(long underReviewClaims) { this.underReviewClaims = underReviewClaims; }
        public long getApprovedClaims() { return approvedClaims; }
        public void setApprovedClaims(long approvedClaims) { this.approvedClaims = approvedClaims; }
        public long getRejectedClaims() { return rejectedClaims; }
        public void setRejectedClaims(long rejectedClaims) { this.rejectedClaims = rejectedClaims; }
        public long getSettledClaims() { return settledClaims; }
        public void setSettledClaims(long settledClaims) { this.settledClaims = settledClaims; }
    }
}
{"ast":null,"code":"import { throwError, BehaviorSubject, EMPTY } from 'rxjs';\nimport { catchError, switchMap, filter, take, finalize } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/auth.service\";\nimport * as i2 from \"@angular/router\";\nexport class AuthInterceptor {\n  constructor(authService, router) {\n    this.authService = authService;\n    this.router = router;\n    this.isRefreshing = false;\n    this.refreshTokenSubject = new BehaviorSubject(null);\n  }\n  intercept(req, next) {\n    // Skip token attachment for authentication endpoints\n    if (this.isAuthEndpoint(req.url)) {\n      return next.handle(req);\n    }\n    const token = this.authService.getToken();\n    // Add auth header if token exists\n    if (token) {\n      req = this.addTokenToRequest(req, token);\n    }\n    return next.handle(req).pipe(catchError(error => {\n      // Handle 401 Unauthorized errors\n      if (error.status === 401 && token && !this.isAuthEndpoint(req.url)) {\n        return this.handle401Error(req, next);\n      }\n      // Handle other errors\n      return throwError(() => error);\n    }));\n  }\n  handle401Error(req, next) {\n    if (!this.isRefreshing) {\n      this.isRefreshing = true;\n      this.refreshTokenSubject.next(null);\n      const refreshToken = this.authService.getRefreshToken();\n      if (refreshToken) {\n        return this.authService.refreshToken(refreshToken).pipe(switchMap(response => {\n          this.isRefreshing = false;\n          this.refreshTokenSubject.next(response.accessToken);\n          // Retry the failed request with new token\n          return next.handle(this.addTokenToRequest(req, response.accessToken));\n        }), catchError(error => {\n          this.isRefreshing = false;\n          this.authService.logout();\n          this.router.navigate(['/auth/login']);\n          return throwError(() => error);\n        }), finalize(() => {\n          this.isRefreshing = false;\n        }));\n      } else {\n        // No refresh token available\n        this.isRefreshing = false;\n        this.authService.logout();\n        this.router.navigate(['/auth/login']);\n        return EMPTY;\n      }\n    } else {\n      // Token refresh is already in progress\n      return this.refreshTokenSubject.pipe(filter(token => token !== null), take(1), switchMap(token => next.handle(this.addTokenToRequest(req, token))));\n    }\n  }\n  addTokenToRequest(req, token) {\n    return req.clone({\n      setHeaders: {\n        'Authorization': `Bearer ${token}`\n      }\n    });\n  }\n  isAuthEndpoint(url) {\n    const authEndpoints = ['/auth/login', '/auth/register', '/auth/refresh-token', '/auth/forgot-password', '/auth/reset-password', '/auth/verify-email'];\n    return authEndpoints.some(endpoint => url.includes(endpoint));\n  }\n  static {\n    this.ɵfac = function AuthInterceptor_Factory(t) {\n      return new (t || AuthInterceptor)(i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i2.Router));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AuthInterceptor,\n      factory: AuthInterceptor.ɵfac\n    });\n  }\n}","map":{"version":3,"names":["throwError","BehaviorSubject","EMPTY","catchError","switchMap","filter","take","finalize","AuthInterceptor","constructor","authService","router","isRefreshing","refreshTokenSubject","intercept","req","next","isAuthEndpoint","url","handle","token","getToken","addTokenToRequest","pipe","error","status","handle401Error","refreshToken","getRefreshToken","response","accessToken","logout","navigate","clone","setHeaders","authEndpoints","some","endpoint","includes","i0","ɵɵinject","i1","AuthService","i2","Router","factory","ɵfac"],"sources":["/Users/mvvkiran/Workspace/Angular/auto-insurance-app/frontend/src/app/core/interceptors/auth.interceptor.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\nimport { Observable, throwError, BehaviorSubject, EMPTY } from 'rxjs';\nimport { catchError, switchMap, filter, take, finalize } from 'rxjs/operators';\nimport { Router } from '@angular/router';\nimport { AuthService } from '../services/auth.service';\nimport { environment } from '../../../environments/environment';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  private isRefreshing = false;\n  private refreshTokenSubject = new BehaviorSubject<any>(null);\n\n  constructor(\n    private authService: AuthService,\n    private router: Router\n  ) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    // Skip token attachment for authentication endpoints\n    if (this.isAuthEndpoint(req.url)) {\n      return next.handle(req);\n    }\n\n    const token = this.authService.getToken();\n    \n    // Add auth header if token exists\n    if (token) {\n      req = this.addTokenToRequest(req, token);\n    }\n\n    return next.handle(req).pipe(\n      catchError((error: HttpErrorResponse) => {\n        // Handle 401 Unauthorized errors\n        if (error.status === 401 && token && !this.isAuthEndpoint(req.url)) {\n          return this.handle401Error(req, next);\n        }\n\n        // Handle other errors\n        return throwError(() => error);\n      })\n    );\n  }\n\n  private handle401Error(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (!this.isRefreshing) {\n      this.isRefreshing = true;\n      this.refreshTokenSubject.next(null);\n\n      const refreshToken = this.authService.getRefreshToken();\n      \n      if (refreshToken) {\n        return this.authService.refreshToken(refreshToken).pipe(\n          switchMap((response) => {\n            this.isRefreshing = false;\n            this.refreshTokenSubject.next(response.accessToken);\n            \n            // Retry the failed request with new token\n            return next.handle(this.addTokenToRequest(req, response.accessToken));\n          }),\n          catchError((error) => {\n            this.isRefreshing = false;\n            this.authService.logout();\n            this.router.navigate(['/auth/login']);\n            return throwError(() => error);\n          }),\n          finalize(() => {\n            this.isRefreshing = false;\n          })\n        );\n      } else {\n        // No refresh token available\n        this.isRefreshing = false;\n        this.authService.logout();\n        this.router.navigate(['/auth/login']);\n        return EMPTY;\n      }\n    } else {\n      // Token refresh is already in progress\n      return this.refreshTokenSubject.pipe(\n        filter(token => token !== null),\n        take(1),\n        switchMap(token => next.handle(this.addTokenToRequest(req, token)))\n      );\n    }\n  }\n\n  private addTokenToRequest(req: HttpRequest<any>, token: string): HttpRequest<any> {\n    return req.clone({\n      setHeaders: {\n        'Authorization': `Bearer ${token}`\n      }\n    });\n  }\n\n  private isAuthEndpoint(url: string): boolean {\n    const authEndpoints = [\n      '/auth/login',\n      '/auth/register',\n      '/auth/refresh-token',\n      '/auth/forgot-password',\n      '/auth/reset-password',\n      '/auth/verify-email'\n    ];\n\n    return authEndpoints.some(endpoint => url.includes(endpoint));\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _asyncToGenerator from \"/Users/mvvkiran/Workspace/Angular/auto-insurance-app/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport class LoadingService {\n  constructor() {\n    this.loadingSubject = new BehaviorSubject({});\n    /**\n     * Observable that emits the current loading state\n     */\n    this.loading$ = this.loadingSubject.asObservable();\n    /**\n     * Observable that emits true if any loading operation is active\n     */\n    this.isLoading$ = this.loading$.pipe(map(loadingStates => Object.values(loadingStates).some(isLoading => isLoading)));\n  }\n  /**\n   * Set loading state for a specific key\n   * @param key - Unique identifier for the loading operation\n   * @param isLoading - Loading state\n   */\n  setLoading(key, isLoading) {\n    const currentState = this.loadingSubject.value;\n    if (isLoading) {\n      this.loadingSubject.next({\n        ...currentState,\n        [key]: true\n      });\n    } else {\n      const {\n        [key]: removed,\n        ...newState\n      } = currentState;\n      this.loadingSubject.next(newState);\n    }\n  }\n  /**\n   * Get loading state for a specific key\n   * @param key - Unique identifier for the loading operation\n   */\n  isLoading(key) {\n    return this.loading$.pipe(map(loadingStates => !!loadingStates[key]));\n  }\n  /**\n   * Get current loading state for a specific key (synchronous)\n   * @param key - Unique identifier for the loading operation\n   */\n  isLoadingSync(key) {\n    const currentState = this.loadingSubject.value;\n    return !!currentState[key];\n  }\n  /**\n   * Clear all loading states\n   */\n  clearAll() {\n    this.loadingSubject.next({});\n  }\n  /**\n   * Get all currently active loading keys\n   */\n  getActiveLoadingKeys() {\n    const currentState = this.loadingSubject.value;\n    return Object.keys(currentState).filter(key => currentState[key]);\n  }\n  /**\n   * Show loading for a specific operation with automatic cleanup\n   * @param key - Unique identifier for the loading operation\n   * @param operation - Promise or Observable to track\n   */\n  trackOperation(key, operation) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.setLoading(key, true);\n      try {\n        if (operation instanceof Promise) {\n          const result = yield operation;\n          return result;\n        } else {\n          // Handle Observable\n          return new Promise((resolve, reject) => {\n            operation.subscribe({\n              next: value => resolve(value),\n              error: error => reject(error),\n              complete: () => {} // Value should be emitted in next\n            });\n          });\n        }\n      } finally {\n        _this.setLoading(key, false);\n      }\n    })();\n  }\n  /**\n   * Show loading with a minimum display time to prevent flickering\n   * @param key - Unique identifier for the loading operation\n   * @param operation - Promise or Observable to track\n   * @param minDuration - Minimum time to show loading (in milliseconds)\n   */\n  trackOperationWithMinDuration(_x, _x2) {\n    var _this2 = this;\n    return _asyncToGenerator(function* (key, operation, minDuration = 500) {\n      _this2.setLoading(key, true);\n      const startTime = Date.now();\n      try {\n        let result;\n        if (operation instanceof Promise) {\n          result = yield operation;\n        } else {\n          // Handle Observable\n          result = yield new Promise((resolve, reject) => {\n            operation.subscribe({\n              next: value => resolve(value),\n              error: error => reject(error)\n            });\n          });\n        }\n        // Ensure minimum duration\n        const elapsedTime = Date.now() - startTime;\n        if (elapsedTime < minDuration) {\n          yield new Promise(resolve => setTimeout(resolve, minDuration - elapsedTime));\n        }\n        return result;\n      } finally {\n        _this2.setLoading(key, false);\n      }\n    }).apply(this, arguments);\n  }\n  /**\n   * Show global loading overlay\n   */\n  showGlobalLoading() {\n    this.setLoading('GLOBAL', true);\n  }\n  /**\n   * Hide global loading overlay\n   */\n  hideGlobalLoading() {\n    this.setLoading('GLOBAL', false);\n  }\n  /**\n   * Check if global loading is active\n   */\n  isGlobalLoading() {\n    return this.isLoading('GLOBAL');\n  }\n  /**\n   * Show page loading\n   */\n  showPageLoading(page) {\n    this.setLoading(`PAGE_${page}`, true);\n  }\n  /**\n   * Hide page loading\n   */\n  hidePageLoading(page) {\n    this.setLoading(`PAGE_${page}`, false);\n  }\n  /**\n   * Check if specific page is loading\n   */\n  isPageLoading(page) {\n    return this.isLoading(`PAGE_${page}`);\n  }\n  static {\n    this.ɵfac = function LoadingService_Factory(t) {\n      return new (t || LoadingService)();\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: LoadingService,\n      factory: LoadingService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["BehaviorSubject","map","LoadingService","constructor","loadingSubject","loading$","asObservable","isLoading$","pipe","loadingStates","Object","values","some","isLoading","setLoading","key","currentState","value","next","removed","newState","isLoadingSync","clearAll","getActiveLoadingKeys","keys","filter","trackOperation","operation","_this","_asyncToGenerator","Promise","result","resolve","reject","subscribe","error","complete","trackOperationWithMinDuration","_x","_x2","_this2","minDuration","startTime","Date","now","elapsedTime","setTimeout","apply","arguments","showGlobalLoading","hideGlobalLoading","isGlobalLoading","showPageLoading","page","hidePageLoading","isPageLoading","factory","ɵfac","providedIn"],"sources":["/Users/mvvkiran/Workspace/Angular/auto-insurance-app/frontend/src/app/core/services/loading.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LoadingService {\n  private loadingSubject = new BehaviorSubject<{[key: string]: boolean}>({});\n  \n  /**\n   * Observable that emits the current loading state\n   */\n  public loading$ = this.loadingSubject.asObservable();\n\n  /**\n   * Observable that emits true if any loading operation is active\n   */\n  public isLoading$ = this.loading$.pipe(\n    map(loadingStates => Object.values(loadingStates).some(isLoading => isLoading))\n  );\n\n  /**\n   * Set loading state for a specific key\n   * @param key - Unique identifier for the loading operation\n   * @param isLoading - Loading state\n   */\n  setLoading(key: string, isLoading: boolean): void {\n    const currentState = this.loadingSubject.value;\n    \n    if (isLoading) {\n      this.loadingSubject.next({\n        ...currentState,\n        [key]: true\n      });\n    } else {\n      const { [key]: removed, ...newState } = currentState;\n      this.loadingSubject.next(newState);\n    }\n  }\n\n  /**\n   * Get loading state for a specific key\n   * @param key - Unique identifier for the loading operation\n   */\n  isLoading(key: string): Observable<boolean> {\n    return this.loading$.pipe(\n      map(loadingStates => !!loadingStates[key])\n    );\n  }\n\n  /**\n   * Get current loading state for a specific key (synchronous)\n   * @param key - Unique identifier for the loading operation\n   */\n  isLoadingSync(key: string): boolean {\n    const currentState = this.loadingSubject.value;\n    return !!currentState[key];\n  }\n\n  /**\n   * Clear all loading states\n   */\n  clearAll(): void {\n    this.loadingSubject.next({});\n  }\n\n  /**\n   * Get all currently active loading keys\n   */\n  getActiveLoadingKeys(): string[] {\n    const currentState = this.loadingSubject.value;\n    return Object.keys(currentState).filter(key => currentState[key]);\n  }\n\n  /**\n   * Show loading for a specific operation with automatic cleanup\n   * @param key - Unique identifier for the loading operation\n   * @param operation - Promise or Observable to track\n   */\n  async trackOperation<T>(key: string, operation: Promise<T> | Observable<T>): Promise<T> {\n    this.setLoading(key, true);\n    \n    try {\n      if (operation instanceof Promise) {\n        const result = await operation;\n        return result;\n      } else {\n        // Handle Observable\n        return new Promise((resolve, reject) => {\n          operation.subscribe({\n            next: (value) => resolve(value),\n            error: (error) => reject(error),\n            complete: () => {} // Value should be emitted in next\n          });\n        });\n      }\n    } finally {\n      this.setLoading(key, false);\n    }\n  }\n\n  /**\n   * Show loading with a minimum display time to prevent flickering\n   * @param key - Unique identifier for the loading operation\n   * @param operation - Promise or Observable to track\n   * @param minDuration - Minimum time to show loading (in milliseconds)\n   */\n  async trackOperationWithMinDuration<T>(\n    key: string, \n    operation: Promise<T> | Observable<T>, \n    minDuration: number = 500\n  ): Promise<T> {\n    this.setLoading(key, true);\n    \n    const startTime = Date.now();\n    \n    try {\n      let result: T;\n      \n      if (operation instanceof Promise) {\n        result = await operation;\n      } else {\n        // Handle Observable\n        result = await new Promise((resolve, reject) => {\n          operation.subscribe({\n            next: (value) => resolve(value),\n            error: (error) => reject(error)\n          });\n        });\n      }\n      \n      // Ensure minimum duration\n      const elapsedTime = Date.now() - startTime;\n      if (elapsedTime < minDuration) {\n        await new Promise(resolve => setTimeout(resolve, minDuration - elapsedTime));\n      }\n      \n      return result;\n    } finally {\n      this.setLoading(key, false);\n    }\n  }\n\n  /**\n   * Show global loading overlay\n   */\n  showGlobalLoading(): void {\n    this.setLoading('GLOBAL', true);\n  }\n\n  /**\n   * Hide global loading overlay\n   */\n  hideGlobalLoading(): void {\n    this.setLoading('GLOBAL', false);\n  }\n\n  /**\n   * Check if global loading is active\n   */\n  isGlobalLoading(): Observable<boolean> {\n    return this.isLoading('GLOBAL');\n  }\n\n  /**\n   * Show page loading\n   */\n  showPageLoading(page: string): void {\n    this.setLoading(`PAGE_${page}`, true);\n  }\n\n  /**\n   * Hide page loading\n   */\n  hidePageLoading(page: string): void {\n    this.setLoading(`PAGE_${page}`, false);\n  }\n\n  /**\n   * Check if specific page is loading\n   */\n  isPageLoading(page: string): Observable<boolean> {\n    return this.isLoading(`PAGE_${page}`);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}